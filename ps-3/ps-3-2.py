'''
Exercise 10.2 (Pg. 456) in Newman
'''
#To-do: Optimise by removing DecaySim.Ns and just letting Atoms carry the numbers. 
#Also, when stepping atoms, generate random numbers for every atom at once

import numpy as np
import matplotlib.pyplot as plt

class Atom():
    '''
    Creates an instance of an atom undergoing radioactive decay.
    t: float    
        The atom's half-life
    branches: dict{Atom: float}
        Dictionary of the possible decay paths of the atom.
        The key of each entry should be another object with the class Atom, 
        and the value should be a float corresponding to the weight of that atom's branch (normalised to 1.)
    parent: bool
        Indicates whether the atom is the first in a decay chain.
    '''
    def __init__(self, name, t=np.inf, branches={}):
        self.name = name
        self.t = np.float64(t)
        self.branches = branches

    def __repr__(self):
        return self.name

    def set_decay_windows(self, dt):
        '''
        Once given the step size dt of the simulation, we can get the probabilities of the atom not decaying/
        decaying along a specific branch. We use these to set up two arrays titled outcomes and window, where 
        outcomes = np.ndarray[Atom] is an array of each possibile decay outcome and window = np.ndarray[float] is the np.cumsum of 
        all the probabilities.
        The idea is that if a random variable x is greater than all window[:i], but less than the next element window[i], then
        the outcome in outcomes[i] is what will occur. If x > all the elements of outcomes, then the atom will not decay.

        Parameters:
        dt: float
            Step size of the simulation, in seconds
        
        Returns:
        outcomes = np.ndarray[Atom]
        windows = np.ndarray[float]
        '''

        #If atom is stable, don't bother looping through the branches dictionary
        if self.t == np.inf:
            self.outcomes = np.array([None])
            self.windows = np.array([-1], dtype=np.float64)

        #Initialise our arrays
        self.outcomes = np.zeros(len(self.branches), dtype=np.object_)
        self.windows = np.zeros(len(self.branches)+1, dtype=np.float64)

        #Get probability of atom decaying/not decaying
        stay_prob = np.power(2., -dt/self.t)
        decay_prob = 1. - stay_prob

        #Get probabilities of atom decaying AND decaying along each specific branch, add to outcomes/windows arrays
        i = 0
        for branch, weight in self.branches.items():
            self.outcomes[i] = branch
            self.windows[i+1] = weight * decay_prob
            i+=1

        #Turn windows array into a cumulative sum; this way we can use a single random variable X to decide between each outcome
        self.windows = np.cumsum(self.windows)

    def atom_step(self, N):
        '''
        Determine whethher the atom decays into another one or stays as it is, 
        with probabilities determined by the user when they instantiated this class.

        N: int
            Number of atoms this function should be run for
        Returns: Atom | None
            One of the Atoms found in self.outcomes, or None.
            Outcome is generated by getting a random number X such that 0 <= X < 1.
                If X > all elements of self.windows, then None is returned and the atom "stays as is."
                If X < any element of self.windows, then the the index i of the leftmost such element is found.
                self.outcomes[i] is then returned.
        '''
        # x = np.random.random() #0 <= x < 1
        # higher = np.where(self.windows > x)[0]
        # if higher.size == 0:
        #     return None
        # else:
        #     return self.outcomes[higher[0]]
        x = np.random.rand(N) #0 <= x < 1
        decays = x[x < self.windows[-1]]
        decay_hist = np.histogram(decays, bins=self.windows)[0]
        # print(f"{self.name}: {decay_hist}")
        # print(self.name, decay_hist)
        return {self.outcomes[i]: decay_hist[i] for i in range(len(decay_hist))}

class DecaySim():
    def __init__(self, dt, steps, atom_dict):
        '''
        Creates a simulation with multiple decaying atom types.
        dt: float
            The time between each step of the simulation
        steps: int
            The number of time steps that the simulation should run for
        atoms: dict{Atom: int}
            A dictionary where each key is an Atom involved in the simulation and each corresponding value
            is the starting number of that type of atom.
        '''
        self.dt = np.float64(dt)
        self.steps = np.uint64(steps)
        self.atoms = np.array(list(atom_dict.keys()), dtype=np.object_)
        self.data = atom_dict

    def get_sim_order(self):
        '''
        Get the order in which we should decay the atoms such that atoms don't decay twice in one step
        (i.e. Find the path from the bottom to the top of the decay tree(s)).

        Returns:
        self.order: np.ndarray[Atom]
            List of atoms, given in the order in which we should simulate their decay.
        '''

        self.order = np.zeros(self.atoms.size, dtype=np.object_)

        i = 0 #Order of the current atom, also the current index of self.order we're working with
        for leaf in [atom for atom in self.atoms if atom.t == np.inf]:
            #Start simulating at the bottom of each decay chain
            # print(leaf.name)
            self.order[i] = leaf
            # print([atom for atom in self.order if atom != np.uint(0)])
            i += 1

        while i < self.atoms.size: #my improvised version of a tree traversal bc i don't want to google
            for atom in self.atoms:
                # print(atom)
                if atom in self.order: #adding an atom twice would be bad
                    # print("skipped")
                    continue
                if np.all(np.in1d(atom.outcomes, self.order, assume_unique=True)): 
                    #Are all of the decay products of this atom already on the order list?
                    self.order[i] = atom
                    # print([atom for atom in self.order if atom != np.uint(0)])
                    i += 1

        np.asarray(self.order)

    def step(self, i):
        #i = the number of the step just before this one
        for atom in self.order:
            # print(atom)
            # for i in range(self.Ns[atom]):
            #     result = atom.atom_step()
            #     # print(result)
            #     if result and self.Ns[atom]:
            #         self.data[atom] -= 1
            #         self.data[result] += 1
            result = atom.atom_step(N = self.data[atom][i-1])
            self.data[atom][i] = self.data[atom][i-1]
            # print(result)
            for outcome, number in result.items():
                self.data[outcome][i] += number
                self.data[atom][i] -= number

    def plot_decays(self, plot_name="Radioactive Decay Plot", save=True, savename="test_plot", format="svg"):
        '''
        Plots the simulated decay curves using Matplotlib.
        plot_name: string
            The title of the plot. This will appear at the top.
        save: bool
            If True, the plot will be saved as the file {savename}.png.
        savename: string
            Name of the saved file. Should have a value if save is set to True.
        format: string
            Extension of the file. Should generally be .png or .svg.
        '''
        for atom in self.atoms:
            plt.plot(self.data['times'], self.data[atom], label=str(atom))

        plt.legend()
        plt.title(plot_name)
        plt.xlabel("Time (s)")
        plt.ylabel("Number of Atoms")
        if save:
            if "." in savename: #Make sure we don't have an extra extension
                savename = savename.split(".")[0]
            plt.savefig(savename, format=format)
        plt.show()

    def write_to_txt(self, filename="test"):
        '''
        Saves the numbers of each atom over time, 
        so you can re-plot later without running the whole sim again.

        filename: string
            The name of the saved file. Should be [something].txt
        '''
        if '.' in filename: #Make sure we don't have an extra extension
            filename = filename.split(".")[0]
        
        data = {str(key): val for key, val in self.data.items()}
        np.savez(filename, **data)

    def run(self, save=True, plot_title="Radioactive Decay of Bismuth-213", savename='testplot', format='svg', write=True, filename='full_data'):
        self.data['times'] = np.linspace(start = 0., stop = self.dt * self.steps, num = self.steps + np.uint64(1))
        for atom in self.atoms:
            atom.set_decay_windows(self.dt)
            N_0 = self.data[atom]
            self.data[atom] = np.zeros(self.data['times'].size, dtype=np.uint)
            self.data[atom][0] = N_0

        self.get_sim_order()

        i = 1
        while i < self.steps + 1:
            print(f"Step {i}/{self.steps}")
            # for key in self.data:
            #     print(key, self.data[key][i])
            self.step(i)
            i += 1
        
        if save: self.plot_decays(plot_name=plot_title, save=True, savename=savename, format=format)
        else: self.plot_decays(plot_name=plot_title, save=False)
        if write: self.write_to_txt(filename)

        # run_dict = {atom.name: atom.Ns for atom in self.atoms}
        # run_dict['times'] = np.linspace(start = 0., stop = self.dt * self.steps, num = self.steps + np.uint64(1))

        # return run_dict
        print(self.data)

def plot_from_npz(infile, plot_title, save=False, savename='plotv2', format='svg', show=False):
    '''
    Plot the data from a file generated by a previous simulation.
    infile: string
        Your file (or the path to it, if it's in a different directory) as a string.
    plot_title: string
        Title of the generated plot.
    save: bool
        If set to True, will save the file using parameters savename and format
    savename: string
        Name of the saved file
    format: string
        Format of the saved file, should generally be .png or .svg
    '''
    fig, ax = plt.subplots()
    arrays = np.load(infile)
    times = arrays['times']
    for key in arrays:
        if key == 'times': continue
        ax.plot(times, arrays[key], label=f"Simulated {key}")
    ax.legend()
    ax.set_title(plot_title)
    ax.set_xlabel('Time (s)')
    ax.set_ylabel('Number of atoms')

    if save: plt.savefig(savename, format)
    if show: plt.show()
    return fig, ax

if __name__ == "__main__":

#-----Running the sim-----#
    #Constants

    t_bi213 = 46. * 60. #Half life of Bi213 atoms (s)
    t_tl209 = 2.2 * 60. #Half life of Tl209 atoms (s)
    t_pb209 = 3.3 * 60. #Half life of Pb209 atoms (s)
    t_bi209 = np.inf    #Bi209 treated as stable (even if it isn't really)
    dt = 1.             #Time steps of 1 s

    bi209 = Atom("Bismuth-209", t_bi209, {})
    pb209 = Atom("Lead-209", t_pb209, {bi209: 1.})
    tl209 = Atom("Thallium-209", t_tl209, {pb209: 1.})
    bi213 = Atom("Bismuth-213", t_bi213, {pb209: 0.9791, tl209: 0.0209})

#-----Unit test for Bismuth-213 atom-----#
    # bi213.set_decay_windows(1)
    # times = np.linspace(0, 20000, 20000+1, dtype=np.uint64)
    # decays = np.zeros_like(times)
    # N = np.zeros_like(times)
    # N[0] = 10000
    # i = 1
    # while i < len(times):
    #     print(i)
    #     decay_dict = bi213.atom_step(N[i-1])
    #     decays[i] = np.sum(list(decay_dict.values()))
    #     N[i] = N[i-1] - decays[i]
    #     i += 1

    # plt.plot(times, N)
    # plt.show()

    sim = DecaySim(dt=1., steps= 20000, atom_dict={
        bi209: 0,
        pb209: 5000,
        tl209: 5000,
        bi213: 10000
    })

    # sim.run(save=False, write=False)

#-----Reconstructing and adding to the plot----#
    fig, ax = plot_from_npz('full_data.npz', 'Radioactive Decay of Bismuth-213')

    times = np.linspace(0, 20000, 20000*10 + 1)

    c12 = 0.0209/((t_bi213/t_tl209) - 1)
    c13 = ((t_bi213/t_tl209) * c12 + 0.9791) / ((t_bi213/t_pb209) - 1)
    c23 = ((t_pb209/t_tl209) * c12) / ((t_pb209/t_tl209) - 1)

    print(c12, c13, c23)
    def n1(t, n): #N(t) for Bismuth-213
        return n * 2 ** (-t/t_bi213), "Bismuth-213"

    def n2(t, n): #N(t) for Thallium-209
        return n * c12 * (-(2 ** (-t/t_tl209)) + (2 ** (-t/t_bi213))), "Thallium-209"

    def n3(t, n): #N(t) for Lead-209
        return n * (-(c23 + c13) * 2 ** (-t/t_pb209) + c23 * 2 ** (-t/t_tl209) + c13 * 2 ** (-t/t_bi213)), "Lead-209"

    def n4(t, n): #N(t) for Bismuth-209
        return n * ((c23 + c13) * 2 ** (-t/t_pb209) - (t_bi213/t_pb209) * c13 * 2 ** (-t/t_bi213) - (t_tl209/t_pb209) * c23 * 2 ** (-t/t_tl209) + 1), "Bismuth-209"

    for n in [n1, n2, n3, n4]:
        ns, name = n(times, 10000)
        ax.plot(times, n(times, 10000)[0], ls='dotted', lw=3, label=f'Expected {name}')
    
    plt.legend()
    # plt.savefig("bismuthdecay.eps", format='eps')
    plt.show()